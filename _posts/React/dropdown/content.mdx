---
title: "점진적으로 드롭다운 메뉴 개선하기"
date: 2024-10-10
description: 당신의 드롭다운 메뉴는 확장성과 유연성이 고려되어있나요 ?
thumbnail: /posts/react/dropdown/thumbnail.jpg
author: DongHyun Lee
caption: /profile.png
---

드롭다운 메뉴는 웹 어플리케이션에서 흔히 볼 수 있는 UI다. 누구나 한 번쯤은 만들어 봤던 경험들이 있을 것이다. 만드는것도 크게 어렵지 않다. 내가 부트캠프를 하면서 많은 사람들의 드롭다운 메뉴는 재사용성과 확장성이 떨어져 남의 코드에 if문이 덕지덕지 붙여지는 것을 경험했었다. 프론트엔드를 배운 웬만한 사람들은 다 만들 수 있다. 하지만 구현에만 초점을 둔 것과 확장성과 유연성을 고려한 것과는 시간이 지남에 따라 큰 차이가 나타난다. 따라서 구현에만 초점을 둔 초안을 바탕으로 점진적으로 어떻게 개선하는지에 대한 나의 방법을 공유하겠다. 지극히 내 주관적인 생각이기 때문에 피드백은 환영이다.

우선 만들기 전에 용어 정리를 할 필요가 있다. 바로 Dropdown Menu와 Select에 대한 차이다. 둘다 비슷한 UI이지만 서로 다른 성격을 띈다. 우리는 디자이너와 소통도 해야하고, 명칭을 제대로 알아야 올바른 요구사항을 만들 수 있다.

- `Dropdown Menu` - 메뉴의 항목을 클릭했을 때에는 특정 동작(페이지 이동, 특정 기능)을 수행하거나, 중첩된 하위 메뉴들을 보여준다는 특징이 있다.
- `Select` - HTML의 Select태그를 생각하면 좋다. 즉 Form에서 사용자한테 입력받기 위해 여러 옵션을 제공해 선택하게 하는 하나의 입력 요소를 말한다.

즉 서로 비슷한 UI이지만 기능에 초점이 다르기 때문에 요구사항 또한 다르다. 실제로 나는 드롭다운 메뉴와 셀렉트를 동시에 쓰려다보니 코드가 많이 지저분해졌던 경험을 했었다.

## 요구사항 정의

드롭다운 메뉴가 닫혀있는 상태와 열려있는 상태로 정의를 해보았다.

#### 메뉴가 닫혀있는 상태

- Dropdown 버튼을 클릭하여 메뉴를 보여준다.

#### 메뉴가 열려있는 상태

- Dropdown 버튼을 클릭하면 메뉴를 닫을 수 있다.
- 하위 메뉴를 클릭하면 특정 동작이 수행하고 메뉴는 닫혀야 한다.
- Dropdown의 바깥을 클릭하였을 때에는 메뉴가 닫혀야 한다.
- 중첩된 메뉴를 가진 하위 메뉴에 Hover를 하면 중첩된 메뉴를 보여주어야 한다.

## 흔히 만드는 드롭다운의 모습

취준, 신입 프론트엔드 개발자들은 다음과 같은 형태로 만드는 경우가 많다. 구글에 검색해도 비슷하게 만든 포스트들이 많이 있다.

```tsx
import { FaAngleDown } from "react-icons/fa6"
import useToggle from "../hooks/useToggle"
import useOutSideClick from "../hooks/useOutSideClick"

export default function Dropdown() {
  const { handleToggle, handleCloseToggle, isToggle } = useToggle()
  const dropdownRef = useOutSideClick<HTMLDivElement>({ onCloseToggle: handleCloseToggle })

  return (
    <div className="relative text-white" ref={dropdownRef}>
      <button
        className="px-3 py-3 bg-gray-800 rounded-lg flex justify-between items-center gap-6"
        onClick={handleToggle}
      >
        드롭다운
        <div>
          <FaAngleDown className={isToggle ? `rotate-180` : `rotate-0`} />
        </div>
      </button>
      {isToggle && (
        <ul className="absolute top-full translate-y-1 bg-gray-800 rounded-lg text-sm w-full p-1 gap-1.5">
          <li className="dropdown-menu-item">
            <button className="w-full p-2">특정 기능</button>
          </li>
          <li className="hover:bg-gray-700 rounded-md relative group">
            <div className="w-full p-2">중첩 메뉴 기능</div>
            <ul className="hidden absolute w-[150px] group-hover:block bg-gray-800 rounded-lg translate-x-full top-0 right-4 p-1 gap-1.5">
              <li className="dropdown-menu-item">
                <button className="w-full p-2">중첩 메뉴 1</button>
              </li>
              <li className="dropdown-menu-item">
                <button className="w-full p-2">중첩 메뉴 2</button>
              </li>
              <li className="dropdown-menu-item">
                <button className="w-full p-2">중첩 메뉴 3</button>
              </li>
            </ul>
          </li>
          <li className="dropdown-menu-item">
            <button className="w-full p-2">페이지 이동 기능</button>
          </li>
        </ul>
      )}
    </div>
  )
}
```

### 문제점.

내가 본 케이스 중에 이렇게 만드는 사람이 정말 많다(로직 분리를 안하는 경우도 있다). 따라서 재사용을 하려면 코드를 복붙해서 새로운 파일을 만들어야한다. 이 문제는 중복된 코드가 많아지며 일관성도 깨지고 유지보수도 하기 힘들어진다. 즉 DRY 원칙을 위반하게 된다. 이 문제를 해결하려고 다음과 같이 하는 경우가 있다.

```tsx
// 버튼과, 메뉴항목들을 따로 컴포넌트로 빼는 경우.
export default function Dropdown() {
  const { handleToggle, handleCloseToggle, isToggle } = useToggle()
  const dropdownRef = useOutSideClick<HTMLDivElement>({ onCloseToggle: handleCloseToggle })

  return (
    <div className="relative text-white" ref={dropdownRef}>
      <DropdownButton title="드롭다운" isToggle={isToggle} onToggle={handleToggle} />
      {isToggle && <DropdownMenu {...기능을 전달받아 사용할 props} />}
    </div>
  )
}

```

버튼과 메뉴를 따로 컴포넌트로 빼면 코드가 짧아져 괜찮다고 느낄 수 있지만 큰 착각이다. 리스트 형태로 정리를 해보자면 다음과 같은 문제가 있다.

- 재사용을 하기 위해선 훅들을 계속 불러와야 한다. 즉 복붙하는것과 큰 차이가 없다.
- DropdownMenu는 재사용할 수 없다. 따라서 새롭게 만들어야 하는 불편함이 생기고, 내부의 스타일링들은 복붙을 하게된다. 즉 유지보수가 안좋아진다. (일명: Shotgun Surgery)
- DropdownMenu는 특정 기능들을 props로 받아와야 하는 경우도 있다. 항목이 많아진다면 많은 props를 전달하는 문제가 생긴다.

코드를 컴포넌트로 감싸 분리만 했기 때문에 큰 의미가 없다. 오히려 복잡성만 증가하게 된다. 드롭다운은 하나의 기능으로 작동해야 한다. 하지만 위 코드는 분리된 느낌이 강하게 든다. 매번 작성해야하는 훅들을 컴포넌트로 감싸 `props.children`을 사용할 수 있지만 버튼과 메뉴에 props 전달하는게 쉽지 않다. 물론 `React.cloneElement`를 사용하면 가능하지만 많은 props를 관리하게되면 복잡성이 증가하게 된다는 문제가 있다.

## 어떻게 개선할 수 있을까?

위 문제를 개선하는건 쉽지 않다. 경험이 있거나 많은 지식을 가지고있는 사람들은 쉽게 할 수 있지만 취준이거나 신입이라면 당연히 어렵다. 스스로 문제를 해결하는것도 중요하지만 이러한 문제를 이미 마주친 개발자들이 많이 있다. 바로 라이브러리들을 만든 사람들이다. 라이브러리를 만든 사람들은 다양한 요구사항에 대응을 하며 작업을 한다. 유명한 라이브러리는 사용하기 쉽고 유연하며 확장성이 열려있다. 즉 우리는 라이브러리의 소스코드를 보면서 분석을 하면된다. Radix UI의 DropdownMenu 소스 코드를 봐보자.

```tsx
<DropdownMenu.Root>
  <DropdownMenu.Trigger>
    <Button variant="soft">
      Options
      <DropdownMenu.TriggerIcon />
    </Button>
  </DropdownMenu.Trigger>
  <DropdownMenu.Content>
    <DropdownMenu.Item shortcut="⌘ E">Edit</DropdownMenu.Item>
    <DropdownMenu.Item shortcut="⌘ D">Duplicate</DropdownMenu.Item>
    <DropdownMenu.Separator />
    <DropdownMenu.Item shortcut="⌘ N">Archive</DropdownMenu.Item>

    <DropdownMenu.Sub>
      <DropdownMenu.SubTrigger>More</DropdownMenu.SubTrigger>
      <DropdownMenu.SubContent>
        <DropdownMenu.Item>Move to project…</DropdownMenu.Item>
        <DropdownMenu.Item>Move to folder…</DropdownMenu.Item>
        <DropdownMenu.Separator />
        <DropdownMenu.Item>Advanced options…</DropdownMenu.Item>
      </DropdownMenu.SubContent>
    </DropdownMenu.Sub>

    <DropdownMenu.Separator />
    <DropdownMenu.Item>Share</DropdownMenu.Item>
    <DropdownMenu.Item>Add to favorites</DropdownMenu.Item>
    <DropdownMenu.Separator />
    <DropdownMenu.Item shortcut="⌘ ⌫" color="red">
      Delete
    </DropdownMenu.Item>
  </DropdownMenu.Content>
</DropdownMenu.Root>
```

형태를 보아하니 합성 컴포넌트(Compound Pattern)를 사용한 모습을 볼 수 있다. 놀라운건 이 코드는 훅을 따로 불러오지 않는다. 내부적으로 상태를 공유하고 있다는 것을 알 수 있고, 드롭다운의 기능이 하나처럼 느껴진다. 합성 컴포넌트를 사용하면 props를 분산시킬 수 있고, 각 컴포넌트가 본연의 역할만 수행하게 되어 재사용성과 유연성이 높아지며, 확장성이 향상된다는 특징이 있다.

현재 우리가 만든 코드를 합성 컴포넌트를 사용해 만든다면 우리도 재사용 가능하고 유연한 컴포넌트를 만들 수 있게 된다. 똑같진 않지만 유사하게 만들어봐보자.

## 초안을 Compound Pattern으로 바꿔보자.

기존에 만들었던 초안을 바탕으로 Compound Pattern을 적용해보면 Radix UI처럼 유사하게 만들 수 있다. 네이밍은 Radix UI를 그대로 따랐다. 내부의 상태는 Context API를 사용했다.

소스코드:

```tsx
// ui/DropdownMenu.tsx
import { createContext, ReactNode, useContext } from "react"
import { FaAngleDown } from "react-icons/fa6"
import useToggle from "../hooks/useToggle"
import useOutSideClick from "../hooks/useOutSideClick"

export interface ChildrenProps {
  children: ReactNode
}

export type DropdownMenuContextType = {
  isToggle: boolean
  handleToggle: () => void
  handleOpenToggle: () => void
  handleCloseToggle: () => void
}

export const DropdownMenuContext = createContext<DropdownMenuContextType>({
  isToggle: false,
  handleToggle: () => {},
  handleOpenToggle: () => {},
  handleCloseToggle: () => {},
})

function useDropdownMenu() {
  const ctx = useContext(DropdownMenuContext)
  if (!ctx) throw new Error("Dropdown Menu에서 사용해주세요.")
  return ctx
}

export function DropdownMenu({ children }: ChildrenProps) {
  const toggleState = useToggle()
  const dropdownRef = useOutSideClick<HTMLDivElement>({ onCloseToggle: toggleState.handleCloseToggle })

  return (
    <DropdownMenuContext.Provider value={toggleState}>
      <div className="relative text-white" ref={dropdownRef}>
        {children}
      </div>
    </DropdownMenuContext.Provider>
  )
}

function DropdownMenuTrigger({ children }: ChildrenProps) {
  const { handleToggle } = useDropdownMenu()
  return (
    <button className="px-3 py-3 bg-gray-800 rounded-lg flex justify-between items-center gap-6" onClick={handleToggle}>
      {children}
    </button>
  )
}

function DropdownMenuTriggerIcon() {
  const { isToggle } = useDropdownMenu()
  return (
    <div>
      <FaAngleDown className={isToggle ? `rotate-180` : `rotate-0`} />
    </div>
  )
}

function DropdownMenuContent({ children }: ChildrenProps) {
  const { isToggle } = useDropdownMenu()
  if (!isToggle) return null
  return (
    <ul className="absolute top-full translate-y-1 bg-gray-800 rounded-lg text-sm w-full p-1 gap-1.5">{children}</ul>
  )
}

function DropdownMenuItem({ children }: ChildrenProps) {
  return (
    <li className="dropdown-menu-item">
      <button className="w-full p-2">{children}</button>
    </li>
  )
}

function DropdownMenuSub({ children }: ChildrenProps) {
  return <li className="hover:bg-gray-700 rounded-md relative group">{children}</li>
}

function DropdownMenuSubTrigger({ children }: ChildrenProps) {
  return <div className="w-full p-2">{children}</div>
}

function DropdownMenuSubContent({ children }: ChildrenProps) {
  return (
    <ul className="hidden absolute w-[150px] group-hover:block bg-gray-800 rounded-lg translate-x-full top-0 right-4 p-1 gap-1.5">
      {children}
    </ul>
  )
}

DropdownMenu.Root = DropdownMenu
DropdownMenu.Trigger = DropdownMenuTrigger
DropdownMenu.Content = DropdownMenuContent
DropdownMenu.Item = DropdownMenuItem
DropdownMenu.TriggerIcon = DropdownMenuTriggerIcon
// Sub
DropdownMenu.Sub = DropdownMenuSub
DropdownMenu.SubTrigger = DropdownMenuSubTrigger
DropdownMenu.SubContent = DropdownMenuSubContent
```

```tsx
// components/Dropdown.tsx
import { DropdownMenu } from "@/ui/DropdownMenu.tsx"
export default function Dropdown() {
  return (
    <DropdownMenu.Root>
      <DropdownMenu.Trigger>
        드롭다운
        <DropdownMenu.TriggerIcon />
      </DropdownMenu.Trigger>
      <DropdownMenu.Content>
        <DropdownMenu.Item>특정 기능</DropdownMenu.Item>
        <DropdownMenu.Sub>
          <DropdownMenu.SubTrigger>중첩 메뉴 기능</DropdownMenu.SubTrigger>
          <DropdownMenu.SubContent>
            <DropdownMenu.Item>중첩 메뉴 기능1</DropdownMenu.Item>
            <DropdownMenu.Item>중첩 메뉴 기능2</DropdownMenu.Item>
            <DropdownMenu.Item>중첩 메뉴 기능3</DropdownMenu.Item>
          </DropdownMenu.SubContent>
        </DropdownMenu.Sub>
        <DropdownMenu.Item>페이지 이동 기능</DropdownMenu.Item>
      </DropdownMenu.Content>
    </DropdownMenu.Root>
  )
}
```

합성 컴포넌트를 사용함으로써 재사용성이 크게 향상됐다. DRY 원칙을 지켰고, 각 컴포넌트가 하나의 역할만 수행하기 때문에 SRP 원칙도 지켜졌다. UI가 더욱 유연해져서, 순서에 맞게 배치하는 것만으로 다양한 드롭다운 UI를 쉽게 만들 수 있으며, 확장성도 높아졌다. 초안에 비해 많이 나아졌다.

## 현재 코드의 문제.

```tsx
DropdownMenu.Root = DropdownMenu
DropdownMenu.Trigger = DropdownMenuTrigger
DropdownMenu.Content = DropdownMenuContent
DropdownMenu.Item = DropdownMenuItem
DropdownMenu.TriggerIcon = DropdownMenuTriggerIcon
// Sub
DropdownMenu.Sub = DropdownMenuSub
DropdownMenu.SubTrigger = DropdownMenuSubTrigger
DropdownMenu.SubContent = DropdownMenuSubContent
```

현재 코드에서는 위와 같이 사용하여 import할 때 모든 컴포넌트들을 불러온다는 문제가 있다. 즉 "내가 사용하지 않는 드롭다운 컴포넌트들도 포함"된다는 말이다. Radix UI를 기반으로 만들어진 Shadcn UI에서는 필요한 컴포넌트들만 import해 불러오고 있다. 불필요한 컴포넌트를 불러오지 않아 성능적으로 더 유리하다. 따라서 현재 작성된 코드도 각각 import할 수 있도록 바꿔 파일의 크기를 줄이는게 좋다.

## Radix UI의 특징.

현재 코드에는 버튼이 DropdownMenuTrigger에 내장되어 있다는 문제도 있다. 버튼 컴포넌트를 DropdownMenuTrigger에 자식으로 넣게되면 HTML 구조상 button안에 button이 있게된다. 이렇게 작성하면 에러가 발생하게 된다.

Radix UI의 특징은 기본적으로 Trigger 컴포넌트가 버튼으로 동작한다. 여기에 asChild라는 props를 전달하면 자식으로 전달된 요소와 Trigger의 기본 상태들을 병합한다는 특징이 있다. 따라서 커스텀 버튼을 다음과 같이 사용할 수 있다.

```tsx
// Trigger에는 button이 내장되어 있지만 asChild를 사용하여 아래 버튼과 병합하고. Trigger에 기본 상태인 드롭다운의 메뉴를 열고, 닫는 상태들을 포함하고 있다.
<DropdownMenuTrigger asChild>
  <Button variant="outline">Open</Button>
</DropdownMenuTrigger>
```
